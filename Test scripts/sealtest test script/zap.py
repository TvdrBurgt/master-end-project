# -*- coding: utf-8 -*-
"""
Created on Mon Sep 27 09:18:52 2021

@author: tvdrb
"""

import numpy as np

from NIDAQ.wavegenerator import blockWave
from NIDAQ.constants import MeasurementConstants


class PatchclampSealTest_zap:
    """Class for doing a patchclamp seal test. A continuous measurement can be done
    of which the data is returned continuously as well.
    We want to use the nidaqmx.task.timing to assign a clock and a conversion rate to the task.
    Then we need to make sure to call the read function regularly to read all the samples automatically generated by the card.

    The measurement for the sealtest does not need to be checked. Only a pop up window in the UI provided asking if the gains
    set in the UI are corresponding to the gains on the patchclamp.
    """

    def __init__(self):
        print('PatchclampSealTest_zap')
        """Initiate all the values."""
        self.constants = MeasurementConstants()
        self.sampleRate = 100000
        self.frequency = self.constants.patchSealFreq
        self.voltMin = self.constants.patchSealMinVol
        self.voltMax = self.constants.patchSealMaxVol
        self.dutycycle = self.constants.patchSealDuty
        self.readNumber = 500  # Readnumber for the measurementThread (should be a multiple of the wavelength)
        
        wave = blockWave(self.sampleRate, self.frequency, self.voltMin, self.voltMax, self.dutycycle)
        self.measurementThread_zap = ContinuousPatchThread_zap(wave, self.sampleRate, self.readNumber)

    def setWave(self, inVolGain, zap_volatge, zap_time):
        self.voltMax = zap_volatge / inVolGain
        self.voltMin = 0 / inVolGain
        self.measurementThread_zap.wave = self.voltMax * np.ones(int(int(zap_time) * 10 / 100 / 100000 * self.sampleRate))
        self.measurementThread_zap.wave = np.append(self.measurementThread_zap.wave, np.zeros(10))  # give 10*0 at the end of waveform

    def start(self):
        self.measurementThread_zap.start()  # Start executing what is inside run()

    def aboutToQuitHandler(self):
        self.measurementThread_zap.requestInterruption()
        self.measurementThread_zap.wait()
    